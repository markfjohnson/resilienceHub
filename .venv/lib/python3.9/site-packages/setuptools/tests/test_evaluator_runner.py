from unittest import TestCase
import boto3

import SampleResourceInventoryEvaluationScripts.war_runner.common.evaluator_runner as er


class Testevaluator_runner(TestCase):
    client = None

    def setUp(self):
        self.client = boto3.client("wellarchitected")
        response = self.client.create_workload(
            WorkloadName='MyTestWar',
            Description='Description',
            Environment='PRODUCTION',
            ReviewOwner='MFJ',
            AwsRegions=[
                "us-east-1"
            ],
            Lenses=[
            ],
            Tags={
                'Product': 'myProduct'
            }
        )
        self.workloadId = response['WorkloadId']

    def tearDown(self):
         response = self.client.delete_workload(
             WorkloadId=self.workloadId
         )

    def test_output_answer_success(self):
        reliability = 'reliability'
        question = "fault-isolation"
        test_note = "Sample output"
        test_choices =  ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"]

        er.evaluator_runner.outputAnswer(self.client, self.workloadId, reliability, question,
                                         ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"], test_note)

        response = self.client.get_answer(
            WorkloadId=self.workloadId,
            LensAlias='wellarchitected',
            QuestionId=question
        )
        found_answer = response['Answer']
        assert found_answer is not None

        found_note = found_answer['Notes']
        assert found_note == test_note

        found_choices = found_answer['SelectedChoices']
        assert len(found_choices) == 2
        assert test_choices[0] in found_choices
        assert test_choices[1] in found_choices

    # def test_output_question_not_found(self):
    #     reliability = 'reliability'
    #     question = "XX"
    #     test_note = "Sample output"
    #     test_choices =  ["rel_fault_isolation_multiaz_region_system",
    #                                       "rel_fault_isolation_select_location"]
    #
    #     er.evaluator_runner.outputAnswer(self.client, self.workloadId, reliability, question,
    #                                      ["rel_fault_isolation_multiaz_region_system",
    #                                       "rel_fault_isolation_select_location"], test_note)
    #
    #     response = self.client.get_answer(
    #         WorkloadId=self.workloadId,
    #         LensAlias='wellarchitected',
    #         QuestionId=question
    #     )
    #     self.assertRaises(Exception)

    def test_output_note_not_found(self):
        reliability = 'reliability'
        question = "fault-isolation"
        test_note = "Sample output"
        test_choices =  ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"]

        er.evaluator_runner.outputAnswer(self.client, self.workloadId, reliability, question,
                                         ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"], test_note)

        response = self.client.get_answer(
            WorkloadId=self.workloadId,
            LensAlias='wellarchitected',
            QuestionId=question
        )
        found_answer = response['Answer']
        assert found_answer is not None

        found_note = found_answer['Notes']
        assert found_note == test_note

    def test_output_BothChoices_not_found(self):
        reliability = 'reliability'
        question = "fault-isolation"
        test_note = "Sample output"
        test_choices =  ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"]

        er.evaluator_runner.outputAnswer(self.client, self.workloadId, reliability, question,
                                         ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"], test_note)

        response = self.client.get_answer(
            WorkloadId=self.workloadId,
            LensAlias='wellarchitected',
            QuestionId=question
        )
        found_answer = response['Answer']
        assert found_answer is not None

        found_choices = found_answer['SelectedChoices']
        assert len(found_choices) == 2
        assert "A" not in found_choices
        assert "B" not in found_choices

    def test_output_UnexpectedChoiceCount(self):
        reliability = 'reliability'
        question = "fault-isolation"
        test_note = "Sample output"
        test_choices =  ["rel_fault_isolation_multiaz_region_system",
                                          "rel_fault_isolation_select_location"]

        er.evaluator_runner.outputAnswer(self.client, self.workloadId, reliability, question,
                                         test_choices, test_note)

        response = self.client.get_answer(
            WorkloadId=self.workloadId,
            LensAlias='wellarchitected',
            QuestionId=question
        )
        found_answer = response['Answer']
        assert found_answer is not None

        found_choices = found_answer['SelectedChoices']
        assert len(found_choices) == 2

    def test_getWorkloadId_not_prexisting(self):
        er_runner = er.evaluator_runner()
        workloadId = er_runner.getWorkloadId(client=self.client, workloadName="Red")
        workload = self.client.get_workload(WorkloadId=workloadId)
        assert(workloadId is not None)
        self.assertEqual("Red", workload['Workload']['WorkloadName'])
        response = self.client.delete_workload(
            WorkloadId=workloadId,
        )

    def test_getWorkloadId_prexisting(self):
        er_runner = er.evaluator_runner()
        workloadId1 = er_runner.getWorkloadId(client=self.client, workloadName="Blue")
        workloadId2 = er_runner.getWorkloadId(client=self.client, workloadName="Blue")
        assert(workloadId2 is not None)
        self.assertEqual(workloadId1, workloadId2)
        workload = self.client.get_workload(WorkloadId=workloadId2)
        self.assertEqual("Blue", workload['Workload']['WorkloadName'])
        response = self.client.delete_workload(
            WorkloadId=workloadId2,
        )
